(* ::Package:: *)

(* 

 :Author: Xah Lee

 : Copyright 1997-2024 by Xah Lee.

 :Summary:

This package is a system for generating all possible wallpaper or plane tiling graphics.

 :Keywords: tiling, symmetry, wallpaper, crystallography, Graphics, geometry

 :Mathematica Version: 2017 or so

 :Package Version: 2, 2024-02-24

 :History: 

Version 0.3, 1998-06.

* Modified the functionality of PolgyonMotif and PolygonMotif2.
The former returns {Lines[...],...} the latter returns {Polygon[...],...}.
Both represents a the Schlafli polygram and polygon of symbol {p/q}.
If p,q are not coprime, then the polygon that is the outline of multiple rotated copies of {(p/GCD[p,q])/(q/GCD[p,q])} are returned.
* Modifed most Motif functions so that symbolic input returns symbolic output.

Version 0.25, 1998-03. Merged the functionality of WallpaperGroupPlot into WallpaperPlot.

Version 0.2, 1997-10-05. A set of graphics cutting functions are added, plus StainedGlassMotif and RandomWallpaperPlot.

Version 0.12b, 1997-09-09. Some changes to function names and implementation.

Version 0.1b, 1997-07. First Released beta.

 :Sources:
B.Grunbaum, G.C.Shephard. Tilings and Patterns. Freeman. 1987.

Doris Schattschneider. The Plane Symmetry Groups: Their recognition and notation. American Math Society. 1978.

J.H. Conway. The orbifold notation for surface groups. Cambridge Univ. Press. 1992. Series: Groups,combinatorics and geometry.

H.S.M. Coxeter. Regular Polytopes. Dover. 1973.

 :Warning: None.

 :Limitations: In this version, the set of graphics cutting functions assume that the points in the graphics does not lie on the cutting line. If they do, then strange polygons may result, probably with some numerical error messages.

 :Discussion:

PlaneTiling is a graphics package for generating wallpaper designs, tilings, plane group symmetry illustrations, and contains general two dimentional graphics tools.
Features include:

* Plot any wallpaper design by specifying a given fundamental motif and wallpaper group symmetry.

* Plot lattice, network, unit cell, fundamental region, generators, and symmetry elements of any specified wallpaper group.

* A system of functions that let you generate any periodic tilings and wallpaper designs easily.

* A system of functions that manipulate Mathematica two dimentional graphics.

* A system of functions that let you apply a topological transformation on regularly directed edges of a tiling.

 Xah Lee
 xah@xahlee.org
 http://xahlee.org/

*)

(* 
2024-02-24 todo
possibly use builtin Translate for copy translate to fill plane, for efficiency reasons.
*)

(* 2024-02-22
todo.
make RotationSymbolMotif2 return symbolic result, if input is exact numbers.
if input is machine number, make sure all computation is machine number.
 *)

(* 2024-02-22
todo
design of RosetteMotif may be problematic.
also, it no implementation Point or other graphics primitives.
also, it's an issue whether the first arg is Graphics object or graphics primitives. it should probably be a graphics object.
might redo using builtin functions and transformation functions.
 *)

(* 2024-02-22 todo
probably remove
Transform2DGraphics
Translate2DGraphics
Rotate2DGraphics
Reflect2DGraphics
GlideReflect2DGraphics.
Use builtin, make sure also replace those who calls it.
*)

BeginPackage["PlaneTiling`"]

Unprotect[LatticeCoordinates,
ColoredLatticePoints,
ColoredLatticeNetwork,
DirectedLatticeNetwork];

Unprotect[SquareLatticeCoordinates,
TriangleLatticeCoordinates,
StarLatticeCoordinates,
HexagonLatticeCoordinates
];

Unprotect[PolygonMotif,
PolygonMotif2,
StarMotif,
NestedPolygonMotif,
RotationSymbolMotif,
RotationSymbolMotif2,

ArrowMotif,
VectorMotif,
DoubleLineMotif,
RosetteMotif,
StainedGlassMotif
];

Unprotect[ LineTransform ];

Unprotect[Transform2DGraphics,
Translate2DGraphics,
Rotate2DGraphics,
Reflect2DGraphics,
GlideReflect2DGraphics];

Unprotect[PolygonCounterOrientedQ,
LineIntersectionPoint,
PointOnLeftSideQ,
PointOnLeftSideQCompiled,
CutPolygon,
SlicePolygon,
SlitLine,
CutLine,
SliceLine,
Wireframe2DGraphics,
ConvertCircleToLine,
Cut2DGraphics,
Slice2DGraphics,
CookieStamp2DGraphics];

Unprotect[WallpaperGroupData,
Translation,
GlideReflection,
Reflection,
Rotation,

MotifGraphics,
BasisVectors,
ShowSymmetryAndUnitCellGraphics,
CenterGraphics,

UnitCellGraphicsFunction,
FundamentalRegionGraphicsFunction,
GlideReflectionGraphicsFunction,
MirrorLineGraphicsFunction,
RotationSymbolGraphicsFunction,

WallpaperPlot,
RandomWallpaperPlot];

Begin["`Private`"]

Clear[LatticeCoordinates];

LatticeCoordinates::"usage" =
"LatticeCoordinates[vectorA,vectorB,{m,n}] return a list of coordinates on a grid generated by vectors vectorA and vectorB with m and n points in each direction.
LatticeCoordinates[vectorA,vectorB,{m,n},s,alpha,{x,y}] scales, rotates, and translates the grid by s, alpha, and {x,y}.
Example:
Graphics[{Map[Point,LatticeCoordinates[{1,0},{1/2,Sqrt[3]/2},{7,5}],{2}]}, Frame -> True]
";

LatticeCoordinates[a_,b_,{m_,n_}]:=
Table[a*i+b*j,{j,0,n-1},{i,0,m-1}];

LatticeCoordinates[a_,b_,{m_,n_},s_]:=
Table[a*s*i+b*s*j,{j,0,n-1},{i,0,m-1}];

LatticeCoordinates[a_,b_,{m_,n_},s_,alpha_]:=
Function[
LatticeCoordinates[#1,#2,{m,n}]
]@@
((({{Cos@alpha,-Sin@alpha},{Sin@alpha,Cos@alpha}}) . #)&/@({a,b}*s))

LatticeCoordinates[a_,b_,{m_,n_},s_,alpha_,{x_,y_}]:=
Map[(#+{x,y})&,LatticeCoordinates[a,b,{m,n},s,alpha],{2}];

Clear[SquareLatticeCoordinates];

SquareLatticeCoordinates::"usage" =
"SquareLatticeCoordinates[n] return a list of coordinates that represents a square lattice.
n is the number of points in one dimention.
SquareLatticeCoordinates[n,s,alpha,{x,y}] scales, rotates, and translates the lattice by s, alpha, and {x,y}.
Example:
Graphics[Map[Point,SquareLatticeCoordinates[5],{2}], Frame -> True]
";

SquareLatticeCoordinates[n_ : 5] :=
 LatticeCoordinates[{1, 0}, {0, 1}, {n, n}]

SquareLatticeCoordinates[n_, s_] :=
 LatticeCoordinates[{1, 0}, {0, 1}, {n, n}, s]

SquareLatticeCoordinates[n_, s_, alpha_] :=
 LatticeCoordinates[{1, 0}, {0, 1}, {n, n}, s, alpha]

SquareLatticeCoordinates[n_, s_, alpha_, {x_, y_}] :=
 LatticeCoordinates[{1, 0}, {0, 1}, {n, n}, s, alpha, {x, y}]

Clear[TriangleLatticeCoordinates];

TriangleLatticeCoordinates::"usage" =
"TriangleLatticeCoordinates[n] return a list of coordinates on a triangular lattice, n cells in each direction, and rotated 3 times.
TriangleLatticeCoordinates[n,s,alpha,{x,y}] scales, rotates, and translates the lattice by s, alpha, and {x,y}.
(Triangular lattice is defined as the vertex set of regular tiling with equilateral triangles)
The returned structure has 3 parts. Each has a parallelogram boundary.
The coordinates are at level 3. e.g. Map[Point,result,{3}].
Example:

With[ {xx = TriangleLatticeCoordinates[6]},
Graphics[
{PointSize[ Large ],
Map[Function[{Red,Point@#}], xx[[1]],{2}],
Map[Function[{Blue,Point@#}], xx[[2]],{2}],
Map[Function[{Cyan,Point@#}], xx[[3]],{2}]
} ,
Frame->True, Axes->True] 
]

Graphics[Map[Point,TriangleLatticeCoordinates[5],{3}], Frame -> True]
";

TriangleLatticeCoordinates[n_Integer] := TriangleLatticeCoordinates[n, 1, 0]

TriangleLatticeCoordinates[n_] := TriangleLatticeCoordinates[n, 1., 0]

TriangleLatticeCoordinates[n_, s_] := TriangleLatticeCoordinates[n, s, 0]

TriangleLatticeCoordinates[n_, s_, alpha_] :=
(Table[
Map[{{Cos@i, -Sin@i}, {Sin@i, Cos@i}} . # &, #, {2}], {i, alpha, alpha + 2*Pi - Pi/3, 2*Pi/3}] &)@
(LatticeCoordinates[{1, 0}, {Cos[2*Pi/3], Sin[2*Pi/3]}, {n, n}, s, 0, {s/2, Sqrt[3]/6*s}]);

TriangleLatticeCoordinates[n_, s_, alpha_, {x_, y_}] :=
 Map[# + {x, y} &, TriangleLatticeCoordinates[n, s, alpha], {3}]

Clear[StarLatticeCoordinates];

StarLatticeCoordinates::"usage" =
 "StarLatticeCoordinates[n] return a list of coordinates that represents a star lattice.
n is the number of points returned.
StarLatticeCoordinates[n,s,alpha,{x,y}] scales, rotates, and translates the lattice by s, alpha, and {x,y}.
(Star lattice is defined as the midpoint of edge set of the regular hexagon tiling)
The returned structure has 3 parts. Each has a parallelogram boundary.
The coordinates are at level 3. e.g. Map[Point,result,{3}].
Example:
Graphics[Map[Point,StarLatticeCoordinates[5],{4}], Frame -> True]
";

StarLatticeCoordinates[n_Integer] :=
 Map[Table[{Cos@t, Sin@t} + #, {t, 0, Pi - 2*Pi/6/2, 2*Pi/6}] &,
   TriangleLatticeCoordinates[n, 2], {3}]

StarLatticeCoordinates[n_?MachineNumberQ] :=
 Map[Table[{Cos@t, Sin@t} + #, {t, 0, Pi - 2*Pi/6/2, 2*Pi/6}] &,
   TriangleLatticeCoordinates[n, 2.],
 {3}]

StarLatticeCoordinates[n_, s_] :=
 Map[(#*s) &, StarLatticeCoordinates[n], {4}]

StarLatticeCoordinates[n_, s_, alpha_] :=
 Map[(({{Cos@alpha, -Sin@alpha}, {Sin@alpha, Cos@alpha}}*
        s) . #) &, StarLatticeCoordinates[n], {4}]

StarLatticeCoordinates[n_, s_, alpha_, {x_, y_}] :=
 Map[(({{Cos@alpha, -Sin@alpha}, {Sin@alpha, Cos@alpha}}*
         s) . # + {x, y}) &, StarLatticeCoordinates[n], {4}]

Clear[HexagonLatticeCoordinates];

HexagonLatticeCoordinates::"usage" =
"HexagonLatticeCoordinates[n] return a list of coordinates that represents a hexagon lattice.
n controls the number of points returned.
HexagonLatticeCoordinates[n,s,alpha,{x,y}] scales, rotates, and translates the lattice by s, alpha, and {x,y}.
(Hexagon lattice is defined as the vertex set of the regular hexagon tiling)
Example:
Graphics[Map[Point,HexagonLatticeCoordinates[5],{4}],Frame -> True] 
";

HexagonLatticeCoordinates[n_ : 5] :=
Map[
Table[{Cos@t, Sin@t} + #, 
{t, 2*Pi/12, 2*Pi/12 + Pi - 2*Pi/6/2, 2*Pi/6}] &, 
TriangleLatticeCoordinates[n, Sqrt[3], 0], {3}]

HexagonLatticeCoordinates[n_, s_] :=
Map[(#*s) &, HexagonLatticeCoordinates[n], {4}]

HexagonLatticeCoordinates[n_, s_, alpha_] :=
 Map[
(({{Cos@alpha, -Sin@alpha}, {Sin@alpha, Cos@alpha}}* s) . #) &, 
HexagonLatticeCoordinates[n], {4}]

HexagonLatticeCoordinates[n_, s_, alpha_, {x_, y_}] :=
 Map[
(({{Cos@alpha, -Sin@alpha}, {Sin@alpha, Cos@alpha}}* s) . # + {x, y}) &, 
HexagonLatticeCoordinates[n], {4}]

Clear[cycledMatrix];

cycledMatrix::"usage" =
"cycledMatrix[{m,n},{row1List,row2List,...}] return a matrix of dimensions {n,m} with elements of row lists cycled repeatedly.
Example:
cycledMatrix[{5,4},{{1,2,3},{a,b}}]
return
{{1, 2, 3, 1, 2}, {a, b, a, b, a}, {1, 2, 3, 1, 2}, {a, b, a, b, a}}
";

cycledMatrix[{m_Integer, n_Integer}, cycleLists : {_List ..}] :=
(Flatten[({Table[#1, {Quotient[#2, #3]}], Take[#1, Mod[#2, #3]]} &) @@ ({#, m, Length@#} &)@#] &) /@
Flatten[
(({(Flatten[#, 1] &)@Table[#1, {Quotient[#2, #3]}],
Take[#1, Mod[#2, #3]]} &) @@ ({#, n, Length@#} &)@ cycleLists), 1];

Clear[ColoredLatticePoints];

ColoredLatticePoints::"usage" =
"ColoredLatticePoints[{a1,a2},{b1,b2},{m,n},{colorList1,colorList2,...}] return a n by m matrix of Points generated by vectors {a1,a2} and {b1,b2}.
colorLists are lists of colors (e.g. Red) or other graphics directives.
colorLists are repeated cyclically.
ColoredLatticePoints[{a1,a2},{b1,b2},{m,n},colorLists,s,alpha,{x,y}] scales, rotates, and translates the lattice by s, alpha, and {x,y}.
Example:
Graphics[{PointSize[.04], ColoredLatticePoints[{1,0},{0,1},{10,7},{{Red,Blue}, {Yellow, Black} }]}]
";

ColoredLatticePoints[a_,b_,{m_Integer,n_Integer},colors:{_List..}]:=
ColoredLatticePoints[a,b,{m,n},colors,1,0,{0,0}];

ColoredLatticePoints[a_,b_,{m_Integer,n_Integer},colors:{_List..},s_]:=
ColoredLatticePoints[a,b,{m,n},colors,s,0,{0,0}];

ColoredLatticePoints[a_,b_,{m_Integer,n_Integer},colors:{_List..},s_,alpha_]:=
ColoredLatticePoints[a,b,{m,n},colors,s,alpha,{0,0}];

ColoredLatticePoints[a_,b_,{m_Integer,n_Integer},colors:{_List..},s_,alpha_,{x_,y_}]:=
(Transpose[{#1,#2},{3,1,2}]&)@@{cycledMatrix[{m,n},colors],(Map[Point,LatticeCoordinates[a,b,{m,n},s,alpha,{x,y}],{2}])};

Clear[ColoredLatticeNetwork];

ColoredLatticeNetwork::"usage" =
"ColoredLatticeNetwork[n,m,{colorList1,colorList2,...}] return a lattice of line segments colored regularly.
A square grid if n is 4, triangular grid if n is 3.
m controls the size of the grid.
Returned list has dimensions {n,2*m+1,2*m,2} and n*(2*m+1)*(2*m) Line segments.
colorLists are lists of colors (e.g. Red) or other graphics directives.
colorLists are repeated cyclically.
ColoredLatticeNetwork[n,m,colorLists,s,alpha,{x,y}] scales, rotates, and translates the lattice by s, alpha, and {x,y}.
Example:
Graphics[{Thickness[.01],ColoredLatticeNetwork[4,3,{{Red,Blue},{Green, Black}}]}]
";

ColoredLatticeNetwork[n:(4|3),m_Integer,colors:{_List..}]:=
ColoredLatticeNetwork[n,m,colors,1,0,{0,0}];

ColoredLatticeNetwork[n:(4|3),m_Integer,colors:{_List..},s_]:=
ColoredLatticeNetwork[n,m,colors,s,0,{0,0}];

ColoredLatticeNetwork[n:(4|3),m_Integer,colors:{_List..},s_,alpha_]:=
ColoredLatticeNetwork[n,m,colors,s,alpha,{0,0}];

ColoredLatticeNetwork[n:(4|3),m_Integer,colors:{_List..},s_,alpha_,{x_,y_}]:=
Module[{lines,gp},

		lines=(Map[Line,#,{2}]&)@(Partition[#,2,1]&/@N@Table[{1,0}*s*i+(({Cos@#,Sin@#}&)@(2*Pi/n))*s*j,{j,-m,m},{i,-m,m}]);
		gp=(Transpose[#,{3,1,2}]&)@{cycledMatrix[{m*2,m*2+1},(RotateRight[#,m]&)@((RotateRight[#,m]&)/@colors)],lines};

	Translate2DGraphics[{x,y}]@Table[Rotate2DGraphics[{0,0},(2*Pi/n)*i+alpha]@gp,{i,0,n-1}]
		];

Clear[DirectedLatticeNetwork];

DirectedLatticeNetwork::"usage" =
"DirectedLatticeNetwork[n,m,{directionList1,directionList2,...}] return a lattice with regularly directed line segments.
A square grid if n is 4, triangular grid if n is 3.
m controls the size of the grid.
Returned list has dimensions {n,2*m+1,2*m,2} and n*(2*m+1)*(2*m) Line segments.
directionLists are lists of True or False values.
directionListss are repeated cyclically.
DirectedLatticeNetwork[n,m,directionLists,s,alpha,{x,y}] scales, rotates, and translates it by s, alpha, and {x,y}.
Example:
Graphics[{LineTransform[(DirectedLatticeNetwork[3,3,{{True}}]),ArrowMotif[{{.5,.4}},.6,0]]}]
";

DirectedLatticeNetwork[allArguments___]:=
ColoredLatticeNetwork[allArguments]/.{{True,Line[pts_]}->Line@pts,{False,Line[pts_]}:>Line@Reverse@pts};

Clear[PolygonMotif];

PolygonMotif::"usage" =
"PolygonMotif[p] return a list of Line that represents a regular p-gon of radius 1.
PolygonMotif[{p,q}] gives star polygon with Schlafli notation {p/q}.
If p and q are not coprime, then GCD[p,q] number of a reduced p/q polygrams are produced.
PolygonMotif[{p,q},s,alpha,{x,y}] scales, rotates and translates it by s, alpha, and {x,y}.
The return value has Length GCD[p,q].
See also: PolygonMotif2, NestedPolygonMotif, StarMotif.
Example:
Graphics[PolygonMotif[{8,3}]]
";

(*Notes:
Input outputs:
Output has the form {Line[...],Line[...],...}, where there are GCD[p,q] elements.
The order of lines is their polygon rotated counter-clockwise.
The "sense" of coordinates inside every Line depends on whether q > p/2.
e.g.
in {8,3}, counter-clockwise; in {8,5}, clockwise.
Implementation note:
p2 and q2 are coprime, derived from p,q.
They are equal if p,q are coprime.*)

PolygonMotif[n_Integer,rest1___]:=
PolygonMotif[{n,1},rest1];

PolygonMotif[{p_Integer,q_Integer}]:=
PolygonMotif[{p,q},1,0,{0,0}];

PolygonMotif[{p_Integer,q_Integer},s_]:=
PolygonMotif[{p,q},s,0,{0,0}];

PolygonMotif[{p_Integer,q_Integer},s_,alpha_]:=
PolygonMotif[{p,q},s,alpha,{0,0}];

PolygonMotif[{p_Integer, q_Integer}, s_, alpha_, {x_, y_}] :=
Module[{p2, q2}, 
{p2, q2} = {p, q}/GCD[p, q];
Line /@ Table[{Cos[t + beta], Sin[t + beta]}*s + {x, y}, 
{beta, 0 + alpha, (2*Pi)/p2 + alpha - ((2*Pi)/p)/2, (2*Pi)/p}, 
{t, 0, (2*Pi)*q2, (2*Pi)/(p2/q2)}]];

(*
PolygonMotif
Old code.

In this old version, each Line connects to two points.
Originally this design decision is made because I thought this package will be Line based and accept such limitations.
Later I decided the package will not accept such limitation.
1998/06/01.

PolygonMotif[{p_Integer,q_Integer},s_,alpha_,{x_,y_}]:=
Map[Line,Transpose[{#,RotateLeft[#,q]}]]&@(Table[{Cos[t],Sin[t]}*s+{x,y},{t,0+alpha,2*Pi+alpha-2*Pi/p/2,2*Pi/p}])

*)

Clear[PolygonMotif2];

PolygonMotif2::"usage" =
"PolygonMotif2[{p,q}] return a Polygon that represents a star polygon with Schlafli notation {p/q}.
If p and q are not coprime, then multiple polygon are generated.
PolygonMotif2[{p,q},s,alpha,{x,y}] scales, rotates and translates it by s, alpha, and {x,y}.
See also: PolygonMotif, NestedPolygonMotif2, StarMotif.
Example:
Graphics[PolygonMotif2[{8,3}]]
";

PolygonMotif2[n_Integer,rest1___]:=
PolygonMotif2[{n,1},rest1];

PolygonMotif2[{p_Integer,q_Integer}]:=
PolygonMotif2[{p,q},1,0,{0,0}];

PolygonMotif2[{p_Integer,q_Integer},s_]:=
PolygonMotif2[{p,q},s,0,{0,0}];

PolygonMotif2[{p_Integer,q_Integer},s_,alpha_]:=
PolygonMotif2[{p,q},s,alpha,{0,0}];

PolygonMotif2[{p_Integer,q_Integer},s_,alpha_,{x_,y_}]:=
Module[{p2,q2},{p2,q2}={p,q}/GCD[p,q];q2=Min[q2,p2-q2];
StarMotif[p,If[q===1,{1},{1, Cos[(Pi*q2)/p2]*Sec[Pi*(1/p - q2/p2)]}],s,alpha,{x,y}]];

(*Implementation notes:

The code is based on elementary geometry.
Given p,q, we want to find the length of the two radii of the star polygon.

Let C be the center of the polygon, B be a convex vertex, A be the neighboring concave vertex.
ABC forms a triangle.
With standard labeling, we have angles alpha,beta,gamma and sides a,b,c.
The length of a is 1.
We need to find the length of b.
All angles can be found from given p,q, thus we can use law of sine to solve for b.

Our problem is a bit more complex because if p,q are not coprime, we want to generate a star polygon that is the superimposed image of GCD[p,q] copies of the polygon {p2/q2} rotated, where p2,q2 are coprime derived by reducing p,q.
The meaning of A,B,C do not need to change.
The formulas are:

(Important: we assume q2<p2/2. Else, the formula for beta needs to be applied by Abs)

beta=(Pi-2*Pi/(p2/q2))/2;
gamma=2*Pi/p/2;
alpha=Pi-(beta+gamma);
using Solve[Sin[alpha]/a == Sin[beta]/b == Sin[gamma]/c,{b}], we get
{b -> a*Cos[(Pi*q2)/p2]*Sec[Pi*(1/p - q2/p2)]}*)

Clear[StarMotif];

(* 2024-02-22
- maybe rename StarMotif to StarPolygon.
- maybe recode so when no scale rotate translate, just hard code. better efficiency.
- maybe redesign so that it doesn't do scale StarMotif to StarPolygon.
 *)

StarMotif::"usage" =
"StarMotif[n,{r1,r2..}] return a Polygon that represents a star shaped polygon of n-fold symmetry and radii r1, r2,...etc.
StarMotif[n,{{r1,theta1},{r2,theta2}..}] uses polar coordinates as vertexes.
StarMotif[n,{...},s,alpha,{x,y}] scales, rotates, and translates it by s, alpha, and {x,y}.
Example:
Graphics[StarMotif[5,{3,1}]]
";

StarMotif[n_Integer, {}]:={};

StarMotif[n_Integer,li_?VectorQ]:=
StarMotif[n,li,1,0,{0,0}];

StarMotif[n_Integer,li_?VectorQ,s_]:=
StarMotif[n,li,s,0,{0,0}];

StarMotif[n_Integer,li_?VectorQ,s_,alpha_]:=
StarMotif[n,li,s,alpha,{0,0}];

StarMotif[n_Integer,li_?MatrixQ]:=
StarMotif[n,li,1,0,{0,0}];

StarMotif[n_Integer,li_?MatrixQ,s_]:=
StarMotif[n,li,s,0,{0,0}];

StarMotif[n_Integer,li_?MatrixQ,s_,alpha_]:=
StarMotif[n,li,s,alpha,{0,0}];

StarMotif[n_Integer,radii_?VectorQ,s_,alpha_,{x_,y_}]:=
StarMotif[n,Transpose[{radii,Table[2*Pi/n/Length@radii*i,{i,0,Length@radii-1}]}],s,alpha,{x,y}];

StarMotif[n_Integer,coords_?MatrixQ,s_,alpha_,{x_,y_}]:=
Polygon@(Flatten[#,1]&)@Transpose@Map[Table[{Cos[t+Last@#],Sin[t+Last@#]}*First[#]*s+{x,y},{t,alpha,2*Pi+alpha-2*Pi/n/2,2*Pi/n}]&,coords];

Clear[NestedPolygonMotif];

NestedPolygonMotif::"usage" =
"NestedPolygonMotif[n,m] return a list of Polygon that represents regular n-gon nested m times.
Each corner of the n-gon rest on the midpoint of another's side.
NestedPolygonMotif[n,m,s,alpha,{x,y}] scales, rotates, and translates by s, alpha, and {x,y}.
The result has Length m.
See also: PolygonMotif, PolygonMotif2, StarMotif.
Example:
Graphics[{NestedPolygonMotif[5, 3] /. poly_Polygon :> {RandomColor[], poly}}]
";

NestedPolygonMotif[n_Integer,m_Integer]:=
NestedPolygonMotif[n,m,1,0,{0,0}];

NestedPolygonMotif[n_Integer,m_Integer,s_]:=
NestedPolygonMotif[n,m,s,0,{0,0}];

NestedPolygonMotif[n_Integer,m_Integer,s_,alpha_]:=
NestedPolygonMotif[n,m,s,alpha,{0,0}];

NestedPolygonMotif[n_Integer, m_Integer, s_, alpha_, {x_, y_}] :=
(Polygon /@
NestList[(Append[#1, First[#1]] &)[(1/2*(First[#1] + Last[#1]) &) /@ Partition[#1, 2, 1]] &,
Table[{Cos[t], Sin[t]}*s + {x, y}, {t, 0 + alpha,  2*Pi + alpha, (2*Pi)/n}], m]) /.
 li_Line :> Drop[li, -1];

Clear[RotationSymbolMotif2];

(*
This is old RotationSymbolMotif, that uses n bars inside a circle to indicate n-fold rotation.
The advantage over traditional rotation symbol is that this maintains consistency over n-fold rotations, while traditional symbol breaks consistency for 2-fold rotation.
The drawback of the new symbol is that it cannot be filled, as to represent rotation centers that's on mirror line.
I decided to go with the traditional symbol.
It looks better in Mathematica.
Mathematica, or rather PostScript, does not render small circles on the screen well.
*)

RotationSymbolMotif2::"usage" =
"RotationSymbolMotif2[n] return a list of graphics primitives that represents n-fold rotation centered on {0,0}.
RotationSymbolMotif2[n,r,alpha,{x,y}] scales, rotates and translates it by r, alpha and {x,y}.
Example:
Graphics[{RotationSymbolMotif2[3]},Frame->True]
";

RotationSymbolMotif2[0]:={};

RotationSymbolMotif2[n_Integer]:=RotationSymbolMotif2[n,1,0,{0,0}];
RotationSymbolMotif2[n_Integer,s_]:=RotationSymbolMotif2[n,s,0,{0,0}];
RotationSymbolMotif2[n_Integer,s_,alpha_]:=RotationSymbolMotif2[n,s,alpha,{0,0}];

RotationSymbolMotif2[n_Integer, s_, alpha_, {x_, y_}] := 
  N@{(Line[{{x, y}, #}]) & /@ (
N@ Table[{Cos[t], Sin[t]}*s + {x, y}, {t, 0 + alpha, 2*Pi + alpha - 2*Pi/n/2, 2*Pi/n}]),
Line@(N@Table[{Cos[t], Sin[t]}*s + {x, y}, {t, 0 + alpha, 2*Pi + alpha, 2*Pi/12}])};

Clear[RotationSymbolMotif];

RotationSymbolMotif::"usage" =
"RotationSymbolMotif[n] return a list of graphics primitives that represents n-fold rotation centered on {0,0}.
RotationSymbolMotif[n,r,alpha,{x,y}] scales, rotates and translates it by r, alpha and {x,y}.
The graphics returned has area 1 for any n.
Example:
Graphics[{RotationSymbolMotif[2]}]
";

(*For a regular n-gon to have area 1, it must have radius Sqrt[2/(Sin[2*Pi/n]*n)]. I got this formula by using law of cosine and Heron's formula on isosceles*)

RotationSymbolMotif[0]:={};
RotationSymbolMotif[1]:={};

RotationSymbolMotif[2]:=With[{s=Sqrt[GoldenRatio/2],h=1/Sqrt[2*GoldenRatio]},Line@{{0,s},{-h,0},{0,-s},{h,0},{0,s}}];

RotationSymbolMotif[3]:=Line@{{0, 2/3^(3/4)},
  {1/3^(1/4), -(1/3^(3/4))},
  {-(1/3^(1/4)), -(1/3^(3/4))},
  {0, 2/3^(3/4)}};

RotationSymbolMotif[4]:=Line@{{1/2, 1/2}, {1/2, -(1/2)}, {-(1/2), -(1/2)}, {-(1/2), 1/2}, {1/2, 1/2}};

RotationSymbolMotif[6]:=Line@{{0, Sqrt[2]/3^(3/4)},
  {1/(Sqrt[2]*3^(1/4)),
   1/(Sqrt[2]*3^(3/4))},
  {1/(Sqrt[2]*3^(1/4)),
   -(1/(Sqrt[2]*3^(3/4)))},
  {0, -(Sqrt[2]/3^(3/4))},
  {-(1/(Sqrt[2]*3^(1/4))),
   -(1/(Sqrt[2]*3^(3/4)))},
  {-(1/(Sqrt[2]*3^(1/4))),
   1/(Sqrt[2]*3^(3/4))},
  {0, Sqrt[2]/3^(3/4)}};

RotationSymbolMotif[n_Integer]:=Line@(Table[{Sin[t],Cos[t]}*Sqrt[2/(Sin[2*Pi/n]*n)],{t,0,2*Pi,2*Pi/n}]);

RotationSymbolMotif[n_Integer,s_]:=RotationSymbolMotif[n,s,0,{0,0}];

RotationSymbolMotif[n_Integer,s_,alpha_]:=RotationSymbolMotif[n,s,alpha,{0,0}];

RotationSymbolMotif[n_Integer,s_,alpha_,{x_,y_}]:=Map[({{Cos[alpha],-Sin[alpha]},{Sin[alpha],Cos[alpha]}} . (#*s)+{x,y})&,RotationSymbolMotif[n],{2}];

Clear[ArrowMotif];

(* 2024-02-22
change ArrowMotif to use builtin Arrow. or simply remove it. check if elsewhere is using it.
 *)

ArrowMotif::"usage" =
"ArrowMotif[{{alpha1,s1}}] return a list of Line that represents an arrow from {0,0} to {1,0} with an arrow head line inclined alpha1 angle and length s1.
ArrowMotif[{{alpha1,s1},{alpha2,s2},...}] uses multiple lines to represent the arrow head.
ArrowMotif[arrowHeadMatix,s,alpha,{x,y}] scales, rotates and translates it by s, alpha and {x,y}.
See also: VectorMotif, DoubleLineMotif.
Example:
Graphics[{ArrowMotif[{{-30*Degree,.1},{30*Degree,.1}},1, 30*Degree,{1,1}]}, Frame->True]
";

ArrowMotif[headList_?MatrixQ]:={Line[{{0,0},{1,0}}],MapThread[Line[{{1,0},{-Cos[#1],Sin[#1]}*#2+{1,0}}]&,Transpose[Partition[Flatten[headList],2]]]};

ArrowMotif[headList_?MatrixQ,s_]:=ArrowMotif[headList,s,0,{0,0}];

ArrowMotif[headList_?MatrixQ,s_,alpha_]:=ArrowMotif[headList,s,alpha,{0,0}];

ArrowMotif[headList_?MatrixQ,s_,alpha_,{x_,y_}]:={Line[{{0,0},{1,0}}],MapThread[Line[{{1,0},{-Cos[#1],Sin[#1]}*#2+{1,0}}]&,Transpose[Partition[Flatten[headList],2]]]}/.li_Line:>Map[(({{Cos@alpha,-Sin@alpha},{Sin@alpha,Cos@alpha}}) . (#*s)+{x,y})&,li,{2}]

Clear[VectorMotif];

VectorMotif::"usage" =
"VectorMotif[{v1,v2}] return a list of Line that represents the vector {v1,v2}.
VectorMotif[{v1,v2},s,alpha,{x,y}] scales, rotates and translates it by s, alpha and {x,y}.
See also: ArrowMotif, DoubleLineMotif.
Example:
Graphics[{VectorMotif[{2,1}]},Frame->True]
";

VectorMotif[{a_,b_}]:=VectorMotif[{a,b},1,0,{0,0}];

VectorMotif[{a_,b_},s_]:=VectorMotif[{a,b},s,0,{0,0}];

VectorMotif[{a_,b_},s_,alpha_]:=VectorMotif[{a,b},s,alpha,{0,0}];

VectorMotif[{a_,b_},s_,alpha_,{x_,y_}]:=
ArrowMotif[{{-30*Degree,.1},{30*Degree,.1}},Sqrt[# . #]&@({a,b}),ArcTan[a,b]+alpha,{x,y}];

Clear[DoubleLineMotif];

DoubleLineMotif::"usage" =
"DoubleLineMotif[{a1,a2},{b1,b2},d] return a pair of parallel Lines from {a1,a2} to {b1,b2} with width d in between.
DoubleLineMotif[d] is equivalent to DoubleLineMotif[{0,0},{1,0},d].
DoubleLineMotif[d,s,alpha,{x,y}] scales, rotates and translates it by s, alpha and {x,y}.
See also: ArrowMotif, VectorMotif.
Example:
Graphics[{DoubleLineMotif[{0,0},{2,1},.1]},Frame->True]
";

DoubleLineMotif[a_?VectorQ,b_?VectorQ,d_]:=DoubleLineMotif[d,Sqrt[(b-a) . (b-a)],ArcTan@@(b-a),a];

DoubleLineMotif[d_]:={Line[{{0,-d/2},{1,-d/2}}],Line[{{0,d/2},{1,d/2}}]};

DoubleLineMotif[d_,s_]:=DoubleLineMotif[d,s,0,{0,0}];

DoubleLineMotif[d_,s_,alpha_]:=DoubleLineMotif[d,s,alpha,{0,0}];

DoubleLineMotif[d_,s_,alpha_,{x_,y_}]:=Map[({{Cos@alpha,-Sin@alpha},{Sin@alpha,Cos@alpha}} . #+{x,y})&,{Line[{{0,-d/2},{s,-d/2}}],Line[{{0,d/2},{s,d/2}}]},{3}];

Clear[RosetteMotif];

RosetteMotif::"usage" =
"RosetteMotif[graphics1,n,mirrorLine] return an n-fold centrally symmetric design based on graphics1.
mirrorLine is either True or False.
graphics1 must be a List of Point (not implemented yet), Line, Polygon (not implemented yet), or a Graphics object.
RosetteMotif[graphics1,n,mirror1,s,alpha,{x,y}] scales, rotates and translates it by s, alpha and {x,y}.
Example:
RosetteMotif[Line[{{1,0},{1,1}}],4,True,1,1,{3,2.53}]
";

RosetteMotif[gra_,n_Integer]:=RosetteMotif[gra,n,False,1,0,{0,0}];

RosetteMotif[gra_,n_Integer,mirror:(True|False)]:=RosetteMotif[gra,n,mirror,1,0,{0,0}];

RosetteMotif[gra_,n_Integer,mirror:(True|False),scale_]:=RosetteMotif[gra,n,mirror,scale,0,{0,0}];

RosetteMotif[gra_,n_Integer,mirror:(True|False),scale_,alpha_]:=RosetteMotif[gra,n,mirror,scale,alpha,{0,0}];

RosetteMotif[gra_,n_Integer,mirror:(True|False),scale_,alpha_,{x_,y_}]:=
	Block[{gra2},
		gra2=If[mirror,gra/.li_Line:>{li,Map[{First@#,-Last@#}&,li,{2}]},gra]/.Line[pt_List]:>Line[pt*scale];
		Table[gra2/.li_Line:>Map[{{Cos[t],Sin[t]},{-Sin[t],Cos[t]}} . #+{x,y}&,li,{2}],{t,alpha,2*Pi+alpha-2*Pi/n/2,2*Pi/n}]
		];

Clear[StainedGlassMotif];

StainedGlassMotif::"usage" =
"StainedGlassMotif[n, sideLength, randomParameter, {i,j}] return a j by i matrix of random Polygon that represents a stained glass.
The pattern is based on regular tiling of triangle, square, or hexagon of sideLength, depending on whether n is 3, 4, or 6.
randomParameter is a real number between 0 and 1 that controls the randomness of the image.
StainedGlassMotif[n,sl,rnd,{{xMin,xMax},{yMin,yMax}}] return graphics that covers a specified rectangle.
Example:
Graphics[{StainedGlassMotif[6,1,.5,{5,4}]/.poly_Polygon:>{RandomColor[], poly}}, AspectRatio->Automatic]
";

StainedGlassMotif[3, s_, r_, {{xMin_, xMax_}, {yMin_, yMax_}}] :=
   Module[{i, j},
    {i, j} = Ceiling[N[{(xMax - xMin)/(s/2), (yMax - yMin)/
           ((Sqrt[3]*s)/2)}]] + 4;
     Translate2DGraphics[(Plus @@ #1/2 & ) /@ {{xMin, xMax},
          {yMin, yMax}} - With[{a = {1, 0}*s*i,
          b = {1/2, Sqrt[3]/2}*s*j}, (a + b)/2 +
          {-(s/2), -((Sqrt[3]*s)/(2*3))}]][StainedGlassMotif[3, s, r,
       {i, j}]]];
StainedGlassMotif[3, s_, r_, {ii_Integer, jj_Integer}] :=
   Module[{pts}, pts = N[Table[{1, 0}*s*i + {1/2, Sqrt[3]/2}*s*j +
         {-(s/2), -((Sqrt[3]*s)/(2*3))}, {j, 0, jj}, {i, 0, ii}]];
     If[N[r] != 0, pts = Map[(1/2)*({Cos[#1], Sin[#1]} & )[
            RandomReal[{0, N[2*Pi]}]]*s*RandomReal[{0, N[r]}] + #1 & ,
        pts, {2}]]; (MapThread[{Polygon[Flatten[{#1, {First[#2]}}, 1]],
          Polygon[Flatten[{{Last[#1]}, #2}, 1]]} & , #1] & ) /@
      Map[Partition[#1, 2, 1] & , Partition[pts, 2, 1], {2}]];

StainedGlassMotif[4, s_, r_, {{xMin_, xMax_}, {yMin_, yMax_}}] :=
   Module[{i, j}, {i, j} = Ceiling[N[{xMax - xMin, yMax - yMin}/s]] +
       4; Translate2DGraphics[(Plus @@ #1/2 & ) /@ {{xMin, xMax},
          {yMin, yMax}} - ((1/2)*(-s + #1*s) & ) /@ {i, j}][
      StainedGlassMotif[4, s, r, {i, j}]]];
StainedGlassMotif[4, s_, r_, {ii_Integer, jj_Integer}] :=
   Module[{pts}, pts = N[Table[{s, 0}*i + {0, s}*j + {-(s/2), -(s/2)},
        {j, 0, jj}, {i, 0, ii}]]; If[N[r] != 0,
      pts = Map[(1/2)*({Cos[#1], Sin[#1]} & )[RandomReal[{0, N[2*Pi]}]]*
           s*RandomReal[{0, N[r]}] + #1 & , pts, {2}]];
     (MapThread[Polygon[Flatten[{#1, Reverse[#2]}, 1]] & , #1] & ) /@
      Map[Partition[#1, 2, 1] & , Partition[pts, 2, 1], {2}]];

StainedGlassMotif[6, s_, r_, {{xMin_, xMax_}, {yMin_, yMax_}}] :=
   Module[{i, j},
    {i, j} = Ceiling[N[{(xMax - xMin)/(Sqrt[3]*s), (yMax - yMin)/
           ((3*s)/2)}]] + 4; Translate2DGraphics[
       (Plus @@ #1/2 & ) /@ {{xMin, xMax}, {yMin, yMax}} -
        {(1/2)*Sqrt[3]*s*i, (3*s*j)/(2*2)}][StainedGlassMotif[6, s, r,
       {i, j}]]];
StainedGlassMotif[6, s_, r_, {ii_Integer, jj_Integer}] :=
   Module[{pts, pts2, gp},
    pts = N[Table[{Sqrt[3]*s, 0}*i + {(1/2)*(-Sqrt[3])*s, -(s/2)},
        {i, 0, ii}]]; pts = (Flatten[#1, 1] & )[
       Transpose[{pts, pts /. {x1_, y1_} :> {x1 + (Sqrt[3]*s)/2,
            y1 - s/2}}]]; pts2 = ({1, -1}*#1 & ) /@ pts;
     pts = (Flatten[#1, 1] & )[Table[Map[{0, 3*s}*i + #1 & ,
         {pts, pts2}, {2}], {i, 0, Ceiling[jj/2]}]];
     pts2 = If[N[r] == 0, pts,
       Map[(1/2)*({Cos[#1], Sin[#1]} & )[RandomReal[{0, N[2*Pi]}]]*s*
           RandomReal[{0, N[r]}] + #1 & , pts, {2}]];
     gp = (MapThread[Polygon[Flatten[{#1, Reverse[#2]}, 1]] & ,
         #1] & ) /@ Map[Partition[#1, 3, 2] & , (Flatten[#1, 1] & )[
         Transpose[({First[#1], Map[Rest, Last[#1], {2}]} & )[
           Transpose[(Partition[#1, 2] & )[Partition[pts2, 2, 1]]]]]],
        {2}]; If[OddQ[jj], Delete[gp, -1], gp]];

Clear[LineTransform];

LineTransform::"usage" =
"LineTransform[graphics1,replacementList] is an L-system like graphical function.
graphics1 is a list of Line or an Graphics object.
replacementList is a List of Line or graphic directives and primitives.
Each Line in graphics1 is replaced by the relation Line[{{0,0},{1,0}}]->replacementList.
LineTransform[graphics1,replacementList,Line[{p1,p2}]] use the relation Line[{p1,p2}]->replacementList.
Example:
LineTransform[Line[{{0,0},{1,0},{1,-1}}],{Line[{{0,0},{1/2,1/2},{1,0}}]}]
";

(*LineTransform code explained:
With two arguments: LineTransform[initialImage_, replacement_]. First we make sure that all line segments stand alone in the form of Line[{p1,p2}]. This is done by (N@initialImage/.line1:Line[{_,_,__}]:>Map[Line,Partition[First@line1,2,1]]).
The general plan is this: replace each line in initialImage by the specified motif. We rotate, scale, and translate the motif to each line's position to do this. alpha is the angle to rotate, and p1 is the translation needed.
With three arguments: LineTransform[initialImage_,replacement_,Line[{p3_,p4_}]]. Here we need to do an extra set of translations and rotations to put the motif in the right position, then move it onto each line in original image. This extra motion is combined into just one motion in the code.*)

LineTransform[initialImage_, replacement_] :=
   N[initialImage] /. line1:Line[{_, _, __}] :>
      Line /@ Partition[First[line1], 2, 1] /.
    Line[{p1_, p2_}] :> Block[{v, alpha, scale},
      v = p2 - p1; alpha = ArcTan @@ v; scale = N[Sqrt[v . v]];
       N[replacement] /. {line2_Line :>
          Map[{{Cos[alpha], -Sin[alpha]}, {Sin[alpha], Cos[alpha]}} . #1*scale +
             p1 & , line2, {2}], Point[pt_] :>
          Point[{{Cos[alpha], -Sin[alpha]}, {Sin[alpha], Cos[alpha]}} . pt*scale +
            p1]}];
LineTransform[initialImage_, replacement_, Line[{p3_, p4_}]] :=
   N[initialImage] /. line1:Line[{_, _, __}] :>
      Line /@ Partition[First[line1], 2, 1] /.
    Line[{p1_, p2_}] :> Block[{v, v2, alpha, scale},
      v = N[p2 - p1]; v2 = N[p4 - p3];
       alpha = N[ArcTan @@ v - ArcTan @@ v2];
       scale = N[Sqrt[v . v]/Sqrt[v2 . v2]]; N[replacement] /.
        {line2_Line :> Map[{{Cos[alpha], -Sin[alpha]}, {Sin[alpha], Cos[alpha]}} . (
                #1 - p3)*scale + p1 & , line2, {2}],
         Point[pt_] :> Point[{{Cos[alpha], -Sin[alpha]}, {Sin[alpha],
                Cos[alpha]}} . (pt - p3)*scale + p1]}];

Clear[Transform2DGraphics];



Transform2DGraphics::"usage" =
"Transform2DGraphics[f][graphics1] applies f to the coordinates of graphics primitves in graphics1.
f is a pure function having argument and output of the form {x,y}.
Some graphics primitves are not supported, such as three argument form of Circle, Disk, or Rectangle.
Example:
Transform2DGraphics[(#+{3,4})&][{PointSize[.05],Point[{0,0}]}]
";

Transform2DGraphics[f_Function][gra_] := 
  gra /. {poly_Polygon :> Map[f, poly, {2}], 
    li_Line :> Map[f, li, {2}], pt_Point :> Map[f, pt, {1}], 
    Text[str_, {a_, b_}, rest___] :> Text[str, f@{a, b}, rest], 
    Circle[{a_, b_}, radius_] :> Circle[f@{a, b}, radius], 
    Disk[{a_, b_}, radius_] :> Disk[f@{a, b}, radius], 
    Rectangle[{xm_, ym_}, {xM_, yM_}] :> 
     Polygon@(f /@ {{xm, ym}, {xM, ym}, {xM, yM}, {xm, yM}})};

Clear[Translate2DGraphics];

Translate2DGraphics::"usage" =
"Translate2DGraphics[{a1,a2}][graphics1] translates graphics1 by the vector {a1,a2}.
Example:
Graphics[Translate2DGraphics[{1,1}][{Line[{{0,0},{1,0},{0,1}}]}],Axes->True]
";

Translate2DGraphics[{0|0.,0|0.}][gra_]:=gra;
Translate2DGraphics[{a1_,a2_}][gra_]:=Transform2DGraphics[(#+{a1,a2})&][gra];

Clear[Rotate2DGraphics];

Rotate2DGraphics::"usage" =
"Rotate2DGraphics[{c1,c2},alpha][graphics1] rotates graphics1 by alpha around {c1,c2}.
Example:
Rotate2DGraphics[{0, 0}, alpha][Point[{1, 0}]] === Point[{Cos[alpha], Sin[alpha]}]
";

Rotate2DGraphics[{_,_},0|0.][gra_]:=gra;

Rotate2DGraphics[{0|0.,0|0.},alpha_][gra_]:=Transform2DGraphics[(({{Cos@alpha,-Sin@alpha},{Sin@alpha,Cos@alpha}}) . (#))&][gra];

Rotate2DGraphics[{a1_,a2_},alpha_][gra_]:=Transform2DGraphics[(({{Cos@alpha,-Sin@alpha},{Sin@alpha,Cos@alpha}}) . (#-{a1,a2})+{a1,a2})&][gra];

Clear[Reflect2DGraphics];
Reflect2DGraphics::"usage" =
"Reflect2DGraphics[][graphics1] reflects graphics1 by y-axes. Reflect2DGraphics[{a1,a2}][graphics1] reflects by the mirror line on vector {a1,a2}. Reflect2DGraphics[{a1,a2},{n1,n2}][graphics1] reflects by a line passing the point {n1,n2} and parallel to the vector {a1,a2}.
Example:
Reflect2DGraphics[{1, 0}][{Line[{{a1, a2}, {b1, b2}, {c1, c3}}]}] === {Line[{{a1, -a2}, {b1, -b2}, {c1, -c3}}]}
";

Reflect2DGraphics[][gra_]:=Reflect2DGraphics[{0,1}][gra];

Reflect2DGraphics[{0,0}][gra_]:=Transform2DGraphics[{-First@#,-Last@#}&][gra];

Reflect2DGraphics[{0,1}][gra_]:=Transform2DGraphics[{-First@#,Last@#}&][gra];

Reflect2DGraphics[{1,0}][gra_]:=Transform2DGraphics[{First@#,-Last@#}&][gra];

Reflect2DGraphics[{1,1}][gra_]:=Transform2DGraphics[{Last@#,First@#}&][gra];

Reflect2DGraphics[{a1_,a2_}][gra_]:=(Rotate2DGraphics[{0,0},ArcTan[a1,a2]])@Reflect2DGraphics[{1,0}]@(Rotate2DGraphics[{0,0},-ArcTan[a1,a2]][gra]);

Reflect2DGraphics[{a1_,a2_},{n1_,n2_}][gra_]:=(Translate2DGraphics[{n1,n2}])@(Reflect2DGraphics[{a1,a2}])@(Translate2DGraphics[-{n1,n2}][gra]);

Clear[GlideReflect2DGraphics];
GlideReflect2DGraphics::"usage" =
"GlideReflect2DGraphics[{a1,a2}][graphics1] glide reflects graphics1 by the vector {a1,a2}. GlideReflect2DGraphics[{a1,a2},{n1,n2}][graphics1] glide reflects by a line passing the point {n1,n2} and parallel to the vector {a1,a2}.
Example:
GlideReflect2DGraphics[{1, 1}, {1, 0}][{Line[{{0, 0}, {1, 0}, {0, 1}}]}] === {Line[{{2, 0}, {2, 1}, {3, 0}}]}
";

GlideReflect2DGraphics[{a1_,a2_}][gra_]:=Translate2DGraphics[{a1,a2}]@(Reflect2DGraphics[{a1,a2}][gra]);

GlideReflect2DGraphics[{a1_,a2_},{n1_,n2_}][gra_]:=Translate2DGraphics[{a1,a2}]@(Reflect2DGraphics[{a1,a2},{n1,n2}][gra]);

Clear[PolygonCounterOrientedQ];
(*Code based on Stan Wagon's book _Mathematica In Acton_ section 10.3.*)
PolygonCounterOrientedQ::"usage" =
"PolygonCounterOrientedQ[pointList] return True if the polygon formed by pointList is counterclockwise oriented, else it return False.
Example:
PolygonCounterOrientedQ[{{0,0},{1,0},{1,1},{0,1}}]
";

PolygonCounterOrientedQ[{{x1_,y1_},{x2_,y2_},{x3_,y3_}}]:=(1===Sign@Chop[Det@({{x1,y1,1},{x2,y2,1},{x3,y3,1}})/2.]);

PolygonCounterOrientedQ[pts:{{_,_}..}]:=Block[{n=Length@pts},PolygonCounterOrientedQ@Part[pts,(Position[#,First@Sort@#][[1,1]]&)@pts+{-1,0,1}/.{0->n,n+1->1}]];

Clear[LineIntersectionPoint,LineIntersectionPointCompiled];
LineIntersectionPoint::"usage" =
"LineIntersectionPoint[{A,B},{C,D}] return the intersection of lines AB and CD.
Example:
LineIntersectionPoint[{{0,0},{1,0}},{{0,0},{0,1}}]
";

If[$VersionNumber<3.,
	LineIntersectionPoint[{{a1_,a2_},{b1_,b2_}},{{c1_,c2_},{d1_,d2_}}]:={a2*b1*c1-a1*b2*c1-a2*b1*d1+a1*b2*d1-a1*c2*d1+b1*c2*d1+a1*c1*d2-b1*c1*d2,a2*b1*c2-a1*b2*c2-a2*c2*d1+b2*c2*d1-a2*b1*d2+a1*b2*d2+a2*c1*d2-b2*c1*d2}/(a2*c1-b2*c1-a1*c2+b1*c2-a2*d1+b2*d1+a1*d2-b1*d2),
	LineIntersectionPointCompiled=Compile[{a1,a2,b1,b2,c1,c2,d1,d2},{a2*b1*c1-a1*b2*c1-a2*b1*d1+a1*b2*d1-a1*c2*d1+b1*c2*d1+a1*c1*d2-b1*c1*d2,a2*b1*c2-a1*b2*c2-a2*c2*d1+b2*c2*d1-a2*b1*d2+a1*b2*d2+a2*c1*d2-b2*c1*d2}/(a2*c1-b2*c1-a1*c2+b1*c2-a2*d1+b2*d1+a1*d2-b1*d2)];
	LineIntersectionPoint[{{a1_,a2_},{b1_,b2_}},{{c1_,c2_},{d1_,d2_}}]:=LineIntersectionPointCompiled[a1,a2,b1,b2,c1,c2,d1,d2]];

Clear[LineIntersectionPoint2,LineIntersectionPoint2Compiled];
LineIntersectionPoint2::"usage" =
"LineIntersectionPoint2[{vec1,pt1},{vec2,pt2}] return the intersection of the following two lines: (1) line passing pt1 and parallel to vec1. (2) line passing pt2 and parallel to vec2. vec1 and vec2 must not be parallel and must not be zero vectors.
Example:
LineIntersectionPoint[{{1,0},{1,0}},{{0,1},{1,0}}]
";

If[$VersionNumber<3.,
	LineIntersectionPoint2[{{a1_,a2_},{b1_,b2_}},{{c1_,c2_},{d1_,d2_}}]:={(a2*b1*c1-a1*b2*c1-a1*c2*d1+a1*c1*d2),(a2*b1*c2-a1*b2*c2-a2*c2*d1+a2*c1*d2)}/(a2*c1-a1*c2),
	LineIntersectionPoint2Compiled=Compile[{a1,a2,b1,b2,c1,c2,d1,d2},{(a2*b1*c1-a1*b2*c1-a1*c2*d1+a1*c1*d2),(a2*b1*c2-a1*b2*c2-a2*c2*d1+a2*c1*d2)}/(a2*c1-a1*c2)];
	LineIntersectionPoint2[{{a1_,a2_},{b1_,b2_}},{{c1_,c2_},{d1_,d2_}}]:=LineIntersectionPoint2Compiled[a1,a2,b1,b2,c1,c2,d1,d2]];

Clear[PointOnLeftSideQ,PointOnLeftSideQCompiled];
PointOnLeftSideQ::"usage" =
"PointOnLeftSideQ[P,{A,B}] return True if point P is on the left side of the line AB. P, A, and B are coordinates of the form {real,real}.
Example:
PointOnLeftSideQ[{0,1},{{0,0},{1,0}}]
";

If[$VersionNumber<3.,
	PointOnLeftSideQ[{p1_,p2_},{{a1_,a2_},{b1_,b2_}}]:=N[(a2-b2)*p1+(-a1+b1)*p2+(-(a2*b1)+ a1*b2)]>0,
	PointOnLeftSideQCompiled=Compile[{p1,p2,a1,a2,b1,b2},N[(a2-b2)*p1+(-a1+b1)*p2+(-(a2*b1)+ a1*b2)]>0];
	PointOnLeftSideQ[{p1_,p2_},{{a1_,a2_},{b1_,b2_}}]:=PointOnLeftSideQCompiled[p1,p2,a1,a2,b1,b2]];

Clear[Wireframe2DGraphics];
Wireframe2DGraphics::"usage" =
"Wireframe2DGraphics[gra] changes Polygon and Rectangle in gra to the form Line[...], and Disk to Circle. Note: the three argument form of Rectangle is not converted. See also: ConvertCircleToLine.
Example:
Wireframe2DGraphics[{Rectangle[{0,0},{2,0}],Polygon[{{0,0},{0,-1},{1,-1}}]}]
";

Wireframe2DGraphics[gp_]:=gp/.{Disk->Circle,Polygon[{a_,rest1__}]:>Line[{a,rest1,a}],Rectangle[{xm_,ym_},{xM_,yM_}]:>Line@{{xm,ym},{xM,ym},{xM,yM},{xm,yM},{xm,ym}}};

Clear[ConvertCircleToLine];

ConvertCircleToLine::"usage" =
"ConvertCircleToLine[gra,maxLength] converts all Circle graphics primitives in gra to Line[...] form with all segments' length less than maxLength. See also: Wireframe2DGraphics.
Example:
ConvertCircleToLine[Circle[{0,0},1],.2]
";

ConvertCircleToLine[gp_,maxLength_]:=gp/.{Circle[{c1_,c2_},0,___]:>Point[{c1,c2}],Circle[{c1_,c2_},(r_)?NumberQ]:>With[{iStep=N[(2*Pi)/Ceiling[(2*r*Pi)/maxLength]]},Line@Table[r*{Cos[t],Sin[t]}+{c1,c2},{t,0,2*Pi,iStep}]],Circle[{c1_,c2_},{a_,b_}]:>With[{iStep=N[(2*Pi)/Ceiling[(2*Pi*Max[a,b])/maxLength]]},Line@Table[{a*Cos[t],b*Sin[t]}+{c1,c2},{t,0,2*Pi,iStep}]],Circle[{c1_,c2_},r_,{a_,b_}]:>With[{iStep=N[(b-a)/Ceiling[(2*r*Pi)/maxLength]]},Line@Table[r*{Cos[t],Sin[t]}+{c1,c2},{t,a,b,iStep}]]};

Clear[Cut2DGraphics];

Cut2DGraphics::"usage" =
"Cut2DGraphics[gra,{A,B}] cut graphics gra by the line AB.
Only Line and Polygon primitives are cut.
Others are untouched.
Example:
Cut2DGraphics[{Polygon[{{0,0},{1,0},{1,1},{0,1}}],Line[{{2,0},{2,1}}]},{{0,1/2},{1,1/2}}]
";

Cut2DGraphics[gp_,cuttingLine:{{_,_},{_,_}}]:=
gp/.{li_Line:>CutLine[li,cuttingLine],poly_Polygon:>CutPolygon[poly,cuttingLine]};

Clear[Slice2DGraphics];

Slice2DGraphics::"usage" =
"Slice2DGraphics[g,{A,B}] cut graphics g by the line AB.
The result has length two.
The first part contain primitives that lie on the left side of the cutting line and the last part are primitives on the right side.
Only Line and Polygon primitives are cut.
Point primitive are separated into sides.
Graphics directives or other primitives are untouched and duplicated in both part of the result.
Example:
Slice2DGraphics[{Polygon[{{0,0},{1,0},{1,1},{0,1}}],Line[{{2,0},{2,1}}]},{{0,1/2},{1,1/2}}]
";

(*0 is used as a temporary head.*)
Slice2DGraphics[gp_, cuttingLine : {{_, _}, {_, _}}] :=
({# /. (0[{a_List, _List}]) :> a, # /. (0[{_List, a_List}]) :> a} &)@
   ReplaceAll[ gp, {li_Line :> 0@SliceLine[li, cuttingLine],
     poly_Polygon :> 0@SlicePolygon[poly, cuttingLine],
     Point[pt_] :>
      0@If[PointOnLeftSideQ[pt,
         cuttingLine], {{Point@pt}, {}}, {{}, {Point@pt}}]}];

Clear[CookieStamp2DGraphics];

CookieStamp2DGraphics::"usage" =
"CookieStamp2DGraphics[gra,{pt1,pt2,...}]] cut and return graphics gra that lies inside the given polygon {pt1,pt2,...}. The polygon must be convex and not cross itself. The returned object is a List, not Graphics.
Example:
Graphics [CookieStamp2DGraphics[(Line/@Table[RandomReal[],{15},{15},{2}]),{{0,0},{1,1/2},{1/2,1}}] , Frame->True]
";

CookieStamp2DGraphics[gra_List,pts:{{_,_}..}]:=Fold[First@Slice2DGraphics[#1,#2]&,gra,((Partition[#,2,1]&)@(Append[#,First@#]&)@If[PolygonCounterOrientedQ@pts,pts,Reverse@pts])];

CookieStamp2DGraphics[gra_Graphics,pts:{{_,_}..}]:=CookieStamp2DGraphics[First@gra,pts];

Clear[CutPolygon];

CutPolygon::"usage" =
"CutPolygon[Polygon[{P1,P2,..}],{A,B}] cut polygon by the line AB.
The polygon can be nonconvex but must not cross itself.
The result polygons have the same orientation as the original.
See also: SlicePolygon.
Example:
CutPolygon[Polygon[{{0,0},{1,0},{1,1}}],{{1/2,0},{1/2,1}}]
";

If[$VersionNumber<3.,CutPolygon[Polygon[pts_],cuttingLine:{{_,_},{_,_}}]:=Module[{vertexes,cutPoints},
			vertexes=Map[(PointOnLeftSideQ[#,cuttingLine]@#)&,pts];

		If[SameQ@@(Head/@vertexes),Return@{Polygon@pts}];
			cutPoints=(If[SameQ@@(Head/@#),Null,LineIntersectionPoint[{#[[1,1]],#[[2,1]]},cuttingLine]]&)/@((Partition[#,2,1]&)@(Flatten[{#,First@#}]&)@vertexes);

			vertexes=(DeleteCases[#,Null,{1}]&)@(Flatten[#,1]&)@Transpose[{pts,cutPoints}];

		cutPoints=Sort@(DeleteCases[#,Null,{1}]&)@cutPoints;

		Polygon/@ReleaseHold@Fold[ReplaceAll[ReleaseHold@#1,{({a___,First@#2,b___,Last@#2,c___}:>Hold@Sequence[{First@#2,b,Last@#2},{Last@#2,c,a,First@#2}]),({a___,Last@#2,b___,First@#2,c___}:>Hold@Sequence[{First@#2,c,a,Last@#2},{Last@#2,b,First@#2}])}]&,{vertexes},Partition[cutPoints,2]]
	],
	CutPolygon[Polygon[pts_],cuttingLine:{{_,_},{_,_}}]:=Module[{vertexes,cutPoints},

			(*This is vertexes tagged with True False head to indicate side.*)
			vertexes=Map[(PointOnLeftSideQ[#,cuttingLine]@#)&,pts];

		(*for efficiency reasons, if all points lies on one side of cutting line, then the function is aborted immediately.*)
		If[SameQ@@(Head/@vertexes),Return@{Polygon@pts}];

		(*This is cut points intermingled with Null.*)
			cutPoints=(If[SameQ@@(Head/@#),Null,LineIntersectionPoint[{#[[1,1]],#[[2,1]]},cuttingLine]]&)/@((Partition[#,2,1]&)@(Flatten[{#,First@#}]&)@vertexes);

		(*This is vertexes and cut points in order of traversing the polygon sides.*)
			vertexes=(DeleteCases[#,Null,{1}]&)@(Flatten[#,1]&)@Transpose[{pts,cutPoints}];

		(*This is a list of cutPoints in order of knife action (may be reversed). (without Null)*)
		cutPoints=Sort@(DeleteCases[#,Null,{1}]&)@cutPoints;

		(*This is a list of cut polygons*)
		Polygon/@Fold[ReplaceAll[#1,{({a___,First@#2,b___,Last@#2,c___}:>Sequence[{First@#2,b,Last@#2},{Last@#2,c,a,First@#2}]),({a___,Last@#2,b___,First@#2,c___}:>Sequence[{First@#2,c,a,Last@#2},{Last@#2,b,First@#2}])}]&,{vertexes},Partition[cutPoints,2]]

		(*for versions prior to 3.0, the following line should be used instead*)
		(*Polygon/@ReleaseHold@Fold[ReplaceAll[ReleaseHold@#1,{({a___,First@#2,b___,Last@#2,c___}:>Hold@Sequence[{First@#2,b,Last@#2},{Last@#2,c,a,First@#2}]),({a___,Last@#2,b___,First@#2,c___}:>Hold@Sequence[{First@#2,c,a,Last@#2},{Last@#2,b,First@#2}])}]&,{vertexes},Partition[cutPoints,2]]*)
	]];

Clear[SlicePolygon];

SlicePolygon::"usage" =
"SlicePolygon[Polygon[{P1,P2,..}],{A,B}] cut polygon by the line AB.
The polygon can be nonconvex but must not cross itself.
The result list has length two.
The first part are polygons that lie on the left side of the cutting line.
The result polygons have the same orientation as the original.
Example:
SlicePolygon[Polygon[{{0,0},{1,0},{1,1}}],{{1/2,0},{1/2,1}}]
";

SlicePolygon[Polygon[pts_],cuttingLine:{{_,_},{_,_}}]:=
({Cases[#,True[b_]:>b,{1}],Cases[#,False[b_]:>b,{1}]}&)@
(((PointOnLeftSideQ[#[[1,2]],cuttingLine])@#&) /@ CutPolygon[Polygon@pts,cuttingLine]);

Clear[SlitLine];

SlitLine::"usage" =
"SlitLine[Line[{P1,P2,..}],{A,B}] cut the line by a segment with endpoints at A and B.
See also: CutLine, SliceLine.
Example:
SlitLine[Line[{{0,0},{1,1},{2,0}}],{{0,1/2},{1,1/2}}]
";

(*This module works on lines with two points only *)
SlitLine[Line[pts:{_List,_List}],cuttingLine:{{_,_},{_,_}}]:=ReplaceAll[(If[SameQ@@(PointOnLeftSideQ[#,cuttingLine]&/@pts),List@Line@pts,If[SameQ@@(PointOnLeftSideQ[#,pts]&/@cuttingLine),List@Line@pts,{Line@{First@pts,cutPoint},Line@{cutPoint,Last@pts}}]]),cutPoint->LineIntersectionPoint[pts,cuttingLine]];

(*This module works on lines that contains more than one point. If all points lies on one side of cutting line, then execution is terminated immediately with Return for efficiency reason.*)

If[$VersionNumber<3.,

	SlitLine[Line[pts_List/;(Length@pts>2)],cuttingLine:{{_,_},{_,_}}]:=Module[{temp},
		If[SameQ@@(temp=PointOnLeftSideQ[#,cuttingLine]&/@pts),Return@List@Line@pts];
		temp=MapThread[And[#1,#2]&,{(UnsameQ@@#&)/@Partition[temp,2,1],(PointOnLeftSideQ[First@cuttingLine,#]=!=PointOnLeftSideQ[Last@cuttingLine,#]&)/@Partition[pts,2,1]}];
		temp=Append[#,Null]&@MapThread[If[#2,0@LineIntersectionPoint[#1,cuttingLine],Null]&,{Partition[pts,2,1],temp}];
		temp=(DeleteCases[#,Null,{1}]&)@Flatten[Transpose@{pts,temp},1];
		(Line/@FixedPoint[(ReleaseHold@#/.{a__,0[pt_],b__}->Hold@Sequence[{a,pt},{pt,b}])&,List@temp,200(*safty limit*)])],

	SlitLine[Line[pts_List/;(Length@pts>2)],cuttingLine:{{_,_},{_,_}}]:=Module[{temp},
		If[SameQ@@(temp=PointOnLeftSideQ[#,cuttingLine]&/@pts),Return@List@Line@pts];
		temp=MapThread[And[#1,#2]&,{(UnsameQ@@#&)/@Partition[temp,2,1],(PointOnLeftSideQ[First@cuttingLine,#]=!=PointOnLeftSideQ[Last@cuttingLine,#]&)/@Partition[pts,2,1]}];
		temp=Append[#,Null]&@MapThread[If[#2,0@LineIntersectionPoint[#1,cuttingLine],Null]&,{Partition[pts,2,1],temp}];
		temp=(DeleteCases[#,Null,{1}]&)@Flatten[Transpose@{pts,temp},1];
		(Line/@ReplaceRepeated[List@temp,{a__,0[pt_],b__}:>Sequence[{a,pt},{pt,b}]])]];

(*(*testing code for SlitLine*)Show[
    Graphics[{Thickness[.02],
        SlitLine[
            Line@Table[Random[],{8},{2}],{{0,0},{1,1}/2}]/.a_Line:>{
              RGBColor[Random[],Random[],Random[]],a},{Red,Thickness[.001],
          Line@{{0,0},{1,1}/2}}}],AspectRatio->Automatic,PlotRange->{{0,1},{0,1}},Frame->True]*)

Clear[CutLine];

CutLine::"usage" =
"CutLine[Line[{P1,P2,..}],{A,B}] cut the line by the line AB.
See also: SlitLine, SliceLine.
Example:
CutLine[Line[{{1,1},{1,-1},{2,1},{2,-1},{3,1},{3,-1}}],{{0,0},{1,0}}]
";

(*This module works on lines with two points only *)
CutLine[Line[pts:{_List,_List}],cuttingLine:{{_,_},{_,_}}]:=
ReplaceAll[
(If[SameQ@@(PointOnLeftSideQ[#,cuttingLine]&/@pts),List@Line@pts,{Line@{First@pts,cutPoint},Line@{cutPoint,Last@pts}}]),
cutPoint->LineIntersectionPoint[pts,cuttingLine]];

(*This module works on lines that contains more than one point. If all points lies on one side of cutting line, then execution is terminated immediately with Return for efficiency reason.*)

If[$VersionNumber<3.,

	CutLine[Line[pts_List/;(Length@pts>2)],cuttingLine:{{_,_},{_,_}}]:=Module[{temp},
		If[SameQ@@(temp=Map[(PointOnLeftSideQ[#,cuttingLine])&,pts]),Return@List@Line@pts];
		temp=MapThread[(If[SameQ@@#2,Null,0@LineIntersectionPoint[#1,cuttingLine]]&),{Partition[pts,2,1],Partition[temp,2,1]}];
		Line/@FixedPoint[(ReleaseHold@#/.{a__,0[pt_],b__}->Hold@Sequence[{a,pt},{pt,b}])&,List@(DeleteCases[#,Null,{1}]&)@Flatten[Transpose@{pts,Append[temp,Null]},1],200(*safty limit*)]
	],

	CutLine[Line[pts_List/;(Length@pts>2)],cuttingLine:{{_,_},{_,_}}]:=Module[{temp},
		If[SameQ@@(temp=Map[(PointOnLeftSideQ[#,cuttingLine])&,pts]),Return@List@Line@pts];
		temp=MapThread[(If[SameQ@@#2,Null,0@LineIntersectionPoint[#1,cuttingLine]]&),{Partition[pts,2,1],Partition[temp,2,1]}];
		Line/@ReplaceRepeated[List@(DeleteCases[#,Null,{1}]&)@Flatten[Transpose@{pts,Append[temp,Null]},1],{a__,0[pt_],b__}:>Sequence[{a,pt},{pt,b}]]
	]];

Clear[SliceLine];

SliceLine::"usage" =
"SliceLine[Line[{P1,P2,..}],{A,B}] cut the line by the line AB.
The result list has length two.
The first part are lines that lie on the left side of the cutting line.
See also: CutLine, SlitLine.
Example:
SliceLine[Line[{{1,1},{1,-1},{2,1},{2,-1},{3,1},{3,-1}}],{{0,0},{1,0}}]
";

SliceLine[Line[pts_List],cuttingLine:{{_,_},{_,_}}]:=DeleteCases[#,Null,{2}]&@(If[PointOnLeftSideQ[First@pts,cuttingLine],#,Reverse@#]&)@Transpose@(Partition[Join[(CutLine[Line@pts,cuttingLine]),{Null,Null,Null}],2]);

Clear[WallpaperGroupData];
WallpaperGroupData::"usage" =
"WallpaperGroupData is a list of data about wallpaper groups, some of which are default values for WallpaperPlot. Each row contains: {ID Number,Conway notation,IUC notation,basis vectors,fundamental region,generators}.
Example:
TraditionalForm@TableForm@WallpaperGroupData";

WallpaperGroupData=Transpose@List[
			Range@17,
			{"o"|"o1","2222","**","xx","*2222","22*","22x","x*","2*22","442","*442","4*2","333","*333","3*3","632","*632"},
			{"p1","p2","pm"|"p1m","pg"|"p1g","pmm"|"p2mm","pmg"|"p2mg","pgg"|"p2gg","cm"|"c1m","cmm"|"c2mm","p4","p4m"|"p4mm","p4g"|"p4gm","p3","p3ml","p3lm","p6","p6m"|"p6mm"},
			{{{1,0},{1/10,7/10}},{{1,0},{1/10,7/10}},{{1,0},{0,-1 + GoldenRatio}},{{1,0},{0,-1 + GoldenRatio}},{{1,0},{0,-1 + GoldenRatio}},{{1,0},{0,-1 + GoldenRatio}},{{1,0},{0,-1 + GoldenRatio}},{{1/Sqrt[1 + 1/GoldenRatio^2],-(1/ (Sqrt[1 + 1/GoldenRatio^2]* GoldenRatio))},{1/Sqrt[1 + 1/GoldenRatio^2],1/(Sqrt[1 + 1/GoldenRatio^2]* GoldenRatio)}},{{1/Sqrt[1 + 1/GoldenRatio^2],-(1/ (Sqrt[1 + 1/GoldenRatio^2]* GoldenRatio))},{1/Sqrt[1 + 1/GoldenRatio^2],1/(Sqrt[1 + 1/GoldenRatio^2]* GoldenRatio)}},{{1,0},{0,1}},{{1,0},{0,1}},{{1,0},{0,1}},{{1,0},{1/2,Sqrt[3]/2}},{{1,0},{1/2,Sqrt[3]/2}},{{1,0},{1/2,Sqrt[3]/2}},{{1,0},{1/2,Sqrt[3]/2}},{{1,0},{1/2,Sqrt[3]/2}}},
			{Polygon[{{0,0},#1,#1+#2,#2}]&,Polygon[{{0,0},#1,#2}]&,Polygon[{{0,0},#1,#1+#2/2,#2/2}]&,Polygon[{{0,0},#1/2,#1/2+#2,#2}]&,Polygon[{{0,0},#1/2,#1/2+#2/2,#2/2}]&,Polygon[{{0,0},#1,#1+#2/4,#2/4}]&,Polygon[{{0,0},#1/2,#1/2+#2/2,#2/2}]&,Polygon[{{0,0},#1,#1+#2}]&,Polygon[{{0,0},#1,#1/2+#2/2}]&,Polygon[{{0,0},#1/2,#1/2+#2/2,#2/2}]&,Polygon[{{0,0},#1/2,#1/2+#2/2}]&,Polygon[{{0,0},#1/2,#2/2}]&,Polygon[{#1,(2*(#1+#2))/3,#2,(#1+#2)/3}]&,Polygon[{(#1+#2)/3,(2*(#1+#2))/3,#2}]&,Polygon[{(#1+#2)/3,#1,#2}]&,Polygon[{{0,0},#1/2,(#1+#2)/3,#2/2}]&,Polygon[{{0,0},#1/2,(#1+#2)/3}]&},
			{{},{Rotation[(#1+#2)/2,Pi]&},{Reflection[#1,#2/2]&},{GlideReflection[#1/2,#2/2]&},{Reflection[#1,#2/2]&,Reflection[#2,#1/2]&},{Reflection[#1,#2/4]&,Rotation[(#1+#2)/2,Pi]&},{GlideReflection[#1/2,#2/4]&,Rotation[(#1+#2)/2,Pi]&},{Reflection[#1+#2]&},{Reflection[-#1+#2,#1]&,Reflection[#1+#2]&},{Rotation[(#1+#2)/2,Pi/2]&},{Reflection[#1+#2]&,Rotation[(#1+#2)/2,Pi/2]&},{Reflection[-(#1/2)+#2/2,#1/2]&,Rotation[(#1+#2)/2,Pi/2]&},{Rotation[(#1+#2)/3,(2*Pi)/3]&},{Reflection[#1+#2]&,Rotation[(#1+#2)/3,(2*Pi)/3]&},{Rotation[(#1+#2)/3,(2*Pi)/3]&,Reflection[#2-#1,#1]&},{Rotation[{0,0},Pi/3]&},{Reflection[#1+#2]&,Rotation[{0,0},Pi/3]&}}
];

Clear[Translation];
Translation::"usage" =
"Translation[{x,y}] represents a translation by the vector {x,y}.";

Clear[GlideReflection];

GlideReflection::"usage" =
"GlideReflection[{x1,y1}] represents a glide reflection by the vector {x1,y1}.
GlideReflection[{x1,y1},{x2,y2}] is a glide reflection by the line parallel to {x1,y1} and passing {x2,y2}.
GlideReflection is used by WallpaperGroupData to represent group generators.";

Clear[Reflection];
Reflection::"usage" =
"Reflection[{x1,y1}] represents the reflection operation by the vector {x1,y1}. Reflection[{x1,y1},{x2,y2}] represents reflection by the line parallel to {x1,y1} and passing {x2,y2}. Reflection is used by WallpaperGroupData to represent group generators.";

Clear[Rotation];
Rotation::"usage" =
"Rotation[{x1,y1},alpha] represents a rotation of angle alpha around {x1,y1}. Rotation is used by WallpaperGroupData to represent group generators.";

Clear[getWallpaperGroupUnitMotif];

getWallpaperGroupUnitMotif[n_Integer,a_?VectorQ,b_?VectorQ,glideF_Function,mirrorF_Function,rotateF_Function]:=With[{z={0,0}},
		Part[Unevaluated[
			List[
		{{},{},{{},{},{},{}}},
		{{},{},{rotateF[2,#]&/@{z,a/2,a,b/2,b,a/2+b/2,a+b/2,b+a/2,a+b},{},{},{}}},
		{{},mirrorF/@{{z,a},{b/2,a+b/2},{b,a+b}},{{},{},{},{}}},
		{glideF/@{{z,a},{b/2,a+b/2},{b,a+b}},{},{{},{},{},{}}},
		{{},mirrorF/@{{z,a},{z,b},{a/2,a/2+b},{b/2,b/2+a},{a,a+b},{b,a+b}},{rotateF[2,#]&/@{z,a/2,a,b/2,b,a/2+b/2,a+b/2,b+a/2,a+b},{},{},{}}},
		{glideF/@{{z,b},{a/2,a/2+b},{a,a+b}},mirrorF/@{{b/4,b/4+a},{b*3/4,b*3/4+a}},{rotateF[2,#]&/@{z,a/2,a,b/2,b,a/2+b/2,a+b/2,b+a/2,a+b},{},{},{}}},
		{glideF/@{{a/4,a/4+b},{b/4,b/4+a},{a*3/4,a*3/4+b},{b*3/4,b*3/4+a}},{},{rotateF[2,#]&/@{z,a/2,a,b/2,b,a/2+b/2,a+b/2,b+a/2,a+b},{},{},{}}},
		{glideF/@{{a/2,a+b/2},{b/2,b+a/2}},mirrorF/@{{z,a+b}},{{},{},{},{}}},
		{glideF/@{{a/2,b/2},{a/2,a+b/2},{b/2,b+a/2},{a+b/2,b+a/2}},mirrorF/@{{z,a+b},{a,b}},{rotateF[2,#]&/@{z,a/2,a,b/2,b,a/2+b/2,a+b/2,b+a/2,a+b},{},{},{}}},
		{{},{},{rotateF[2,#]&/@{a/2,b/2,a+b/2,b+a/2},{},rotateF[4,#]&/@{z,a,b,a/2+b/2,a+b},{}}},
		{glideF/@{{a/2,b/2},{a/2,a+b/2},{b/2,b+a/2},{a+b/2,b+a/2}},mirrorF/@{{z,a+b},{z,a},{z,b},{a/2,a/2+b},{b/2,b/2+a},{a,b},{a,a+b},{b,a+b}},{rotateF[2,#]&/@{a/2,b/2,a+b/2,b+a/2},{},rotateF[4,#]&/@{z,a,b,a/2+b/2,a+b},{}}},
		{glideF/@{{z,a+b},{a/4,a/4+b},{b/4,b/4+a},{a*3/4,a*3/4+b},{b*3/4,b*3/4+a},{a,b}},mirrorF/@{{a/2,b/2},{a/2,a+b/2},{b/2,b+a/2},{a+b/2,b+a/2}},{rotateF[2,#]&/@{a/2,b/2,a+b/2,b+a/2},{},rotateF[4,#]&/@{z,a,b,a/2+b/2,a+b},{}}},
		{{},{},{{},rotateF[3,#]&/@{z,a,b,(a+b)*1/3,(a+b)*2/3,a+b},{},{}}},
		{glideF/@{{a/4,b/2},{b/4,a/2},{a/2,a+b/2},{b/2,b+a/2},{a*3/4,a/4+b},{b*3/4,b/4+a},{a+b/2,a*3/4+b},{b+a/2,b*3/4+a}},mirrorF/@{{z,a+b},{a/2,b},{b/2,a},{a,a/2+b},{b,b/2+a}},{{},rotateF[3,#]&/@{z,a,b,(a+b)*1/3,(a+b)*2/3,a+b},{},{}}},
		{glideF/@{{a/2,b/2},{a/2,a/2+b},{b/2,b/2+a},{a+b/2,b+a/2}},mirrorF/@{{z,a},{z,b},{a,b},{a,a+b},{b,a+b}},{{},rotateF[3,#]&/@{z,a,b,(a+b)*1/3,(a+b)*2/3,a+b},{},{}}},
		{{},{},{rotateF[2,#]&/@{a/2,b/2,a/2+b/2,a+b/2,b+a/2},rotateF[3,#]&/@{(a+b)*1/3,(a+b)*2/3},{},rotateF[6,#]&/@{z,a,b,a+b}}},
		{glideF/@{{a/4,b/2},{b/4,a/2},{a/2,b/2},{a/2,a/2+b},{b/2,b/2+a},{a/2,a+b/2},{b/2,b+a/2},{a*3/4,a/4+b},{b*3/4,b/4+a},{a+b/2,b+a/2},{a+b/2,a*3/4+b},{b+a/2,b*3/4+a}},mirrorF/@{{z,a+b},{z,a},{z,b},{a/2,b},{b/2,a},{a,b},{a,a/2+b},{b,b/2+a},{a,a+b},{b,a+b}},{rotateF[2,#]&/@{a/2,b/2,a/2+b/2,a+b/2,b+a/2},rotateF[3,#]&/@{(a+b)*1/3,(a+b)*2/3},{},rotateF[6,#]&/@{z,a,b,a+b}}}
			]
			],n]
	];

Clear[fundamentalMotifToUnitMotif];

fundamentalMotifToUnitMotif[n_Integer,motif_,v1_?VectorQ,v2_?VectorQ]:=(Fold[(If[Head@#2===Rotate2DGraphics,Table[Rotate2DGraphics[First@#2,Last@#2*i][#1],{i,0,2*Pi/Last@#2-1}],{#1,#2@#1}]&),motif,#]&)@(Through[(WallpaperGroupData[[n,6]]/.{GlideReflection->GlideReflect2DGraphics,Reflection->Reflect2DGraphics,Rotation->Rotate2DGraphics})[v1,v2]]);

Clear[MotifGraphics];
MotifGraphics::"usage" =
"MotifGraphics is an option for WallpaperPlot. MotifGraphics->gra specifies a fundamental motif to be used. gra must be a list of Point, Line, Polygon, and graphics directives, or a Graphics object. The default is MotifGraphics->(N@Line[{{2/12,1/12},{5/12,1/12},{5/12,2/12}}]).";

Clear[BasisVectors];
BasisVectors::"usage" =
"BasisVectors is an option for WallpaperPlot and RandomWallpaperPlot. BasisVectors->{{a1,a2},{b1,b2}} specifies the two basis vectors that generate the unit cell. Default is BasisVectors->Automatic. For exact default values, see WallpaperGroupData.";

(*PlotPoints*)

Clear[ShowSymmetryAndUnitCellGraphics];
ShowSymmetryAndUnitCellGraphics::"usage" =
"ShowSymmetryAndUnitCellGraphics is an option for WallpaperPlot. ShowSymmetryAndUnitCellGraphics->True specifies WallpaperPlot to draw symmetry elements and unit cell boundaries. The default is False.";

Clear[CenterGraphics];
CenterGraphics::"usage" =
"CenterGraphics is an option for WallpaperPlot. CenterGraphics->True specifies WallpaperPlot to center the graphics on {0,0}. The default is False.";

Clear[UnitCellGraphicsFunction];

UnitCellGraphicsFunction::"usage" =
"UnitCellGraphicsFunction is an option for WallpaperPlot.
UnitCellGraphicsFunction->f specifies that f is used to generate graphics primitives to represent unit cells.
f must be a pure function that accepts one argument, having the form {{x1,y1},{x2,y2},...}.
The list is the vertex set of some polygon.
f must return graphics primitives.
The default is UnitCellGraphicsFunction->({Hue[0.18],Polygon[#]}&).";

Clear[FundamentalRegionGraphicsFunction];

FundamentalRegionGraphicsFunction::"usage" =
"FundamentalRegionGraphicsFunction is an option for WallpaperPlot.
FundamentalRegionGraphicsFunction->f specifies that f is used to draw fundamental regions.
f must be a pure function that accepts one argument, having the form {{x1,y1},{x2,y2},...}.
The list is the vertex set of some polygon.
f must return graphics primitives.
The default is FundamentalRegionGraphicsFunction->({GrayLevel[0.4],Polygon[#]}&).";

Clear[GlideReflectionGraphicsFunction];

GlideReflectionGraphicsFunction::"usage" =
"GlideReflectionGraphicsFunction is an option for WallpaperPlot.
GlideReflectionGraphicsFunction->(f) specifies that f is used to draw glide reflection lines.
f must be a pure function that accepts two arguments in the form of {a1,a2} and {b1,b2}, representing the end points of a glide reflection line.
f must return a list of graphics primitives.
The default is GlideReflectionGraphicsFunction->({AbsoluteDashing[{5,5}],Line[{#1,#2}]}&).";

Clear[MirrorLineGraphicsFunction];

MirrorLineGraphicsFunction::"usage" =
"MirrorLineGraphicsFunction is an option for WallpaperPlot.
MirrorLineGraphicsFunction->f specifies that f is used to draw mirror lines.
f must be a pure function that accepts two arguments in the form of {a1,a2} and {b1,b2}, representing the end points of an mirror line.
f must return a list of graphics primitives.
The default is MirrorLineGraphicsFunction->(DoubleLineMotif[#1,#2,.05]&).
Example:
WallpaperPlot[17,MotifGraphics->{},ShowSymmetryAndUnitCellGraphics->True,GlideReflectionGraphicsFunction->({Blue,Line[{#1,#2}]}&),MirrorLineGraphicsFunction->({Red,Line[{#1,#2}]}&),PlotPoints->2]
";

Clear[RotationSymbolGraphicsFunction];

RotationSymbolGraphicsFunction::"usage" =
"RotationSymbolGraphicsFunction is an option for WallpaperPlot.
RotationSymbolGraphicsFunction->f specifies that f is used to draw rotation symbols.
f must be a pure function that accepts two arguments, an integer n and a coordinate {a,b}, representing the order and center of rotation respectively.
f must return a list of graphics primitives.
The default is RotationSymbolGraphicsFunction->({{GrayLevel[1],RotationSymbolMotif[#1,.1,0,#2]/.Line->Polygon},RotationSymbolMotif[#1,.1,0,#2]}&).
Example:
WallpaperPlot[16,MotifGraphics->{},ShowSymmetryAndUnitCellGraphics->True,RotationSymbolGraphicsFunction->({Text[#1,#2]}&),UnitCellGraphicsFunction->({}&)]
";

Clear[WallpaperPlot];

WallpaperPlot::"usage" =
"WallpaperPlot[n] plots a wallpaper having symmetry ID n. 1 <= n <= 17. WallpaperPlot[\"Conway notation\"] and WallpaperPlot[\"IUC notation\"] can also be used.
Example:
WallpaperPlot[17]
";

(* Options[WallpaperPlot]=Union[{MotifGraphics->(N@Line[{{2/12,1/12},{5/12,1/12},{5/12,2/12}}]),BasisVectors->Automatic,PlotPoints->{4,4},CenterGraphics->False,ShowSymmetryAndUnitCellGraphics->False,UnitCellGraphicsFunction->(Line@Append[#,First@#]&),FundamentalRegionGraphicsFunction->({}&),GlideReflectionGraphicsFunction->({AbsoluteDashing[{5,5}],Line[{#1,#2}]}&),MirrorLineGraphicsFunction->(DoubleLineMotif[#1,#2,.05]&)(\*({Red,Line[{#1,#2}]}&)*\),RotationSymbolGraphicsFunction->({{GrayLevel[1],RotationSymbolMotif[#1,.1,0,#2]/.Line->Polygon},RotationSymbolMotif[#1,.1,0,#2]}&)},(Options[Graphics]/.{(AspectRatio->_):>(AspectRatio->Automatic)})]; *)

Options[WallpaperPlot] =
  Union[{MotifGraphics -> (N@
       Line[{{2/12, 1/12}, {5/12, 1/12}, {5/12, 2/12}}]),
    BasisVectors -> Automatic, PlotPoints -> {4, 4},
    CenterGraphics -> False, ShowSymmetryAndUnitCellGraphics -> False,
     UnitCellGraphicsFunction -> (Line@Append[#, First@#] &),
    FundamentalRegionGraphicsFunction -> ({} &),
    GlideReflectionGraphicsFunction -> ({AbsoluteDashing[{5, 5}],
        Line[{#1, #2}]} &),
    MirrorLineGraphicsFunction -> (DoubleLineMotif[#1, #2, .05] &),
    RotationSymbolGraphicsFunction -> ({{GrayLevel[1],
         RotationSymbolMotif[#1, .1, 0, #2] /. Line -> Polygon},
        RotationSymbolMotif[#1, .1, 0, #2]} &)}, (Options[
      Graphics] /. {(AspectRatio -> _) :> (AspectRatio ->
         Automatic)})];

(*({Red,Line[{#1,#2}]}&)*)

WallpaperPlot[n_Integer, opts___Rule] :=
   Module[{lMotifGraphics, lBasisVectors, lPlotPoints,
     lShowSymmetryAndUnitCellGraphics, lCenterGraphics, UnitCellGF,
     FundamentalRegionGF, GlideReflectionGF, MirrorLineGF,
     RotationSymbolGF, unitCellGP, fundamentalRegionGP, wallpaperGP,
     symmetryElementsGP}, {lMotifGraphics, lBasisVectors, lPlotPoints,
       lShowSymmetryAndUnitCellGraphics, lCenterGraphics} =
      {MotifGraphics, BasisVectors, PlotPoints,
         ShowSymmetryAndUnitCellGraphics, CenterGraphics} /. {opts} /.
       Options[WallpaperPlot]; {UnitCellGF, FundamentalRegionGF,
       GlideReflectionGF, MirrorLineGF, RotationSymbolGF} =
      {UnitCellGraphicsFunction, FundamentalRegionGraphicsFunction,
         GlideReflectionGraphicsFunction, MirrorLineGraphicsFunction,
         RotationSymbolGraphicsFunction} /. {opts} /.
       Options[WallpaperPlot]; lPlotPoints =
      {First[Flatten[{lPlotPoints}]], Last[Flatten[{lPlotPoints}]]};
     If[lBasisVectors === Automatic, lBasisVectors =
       N[WallpaperGroupData[[n,4]]]]; If[Head[lMotifGraphics] ===
       Graphics, lMotifGraphics = First[lMotifGraphics]];
     {unitCellGP, fundamentalRegionGP, symmetryElementsGP} =
      If[lShowSymmetryAndUnitCellGraphics,
       {UnitCellGF[{{0, 0}, First[lBasisVectors],
          Plus @@ lBasisVectors, Last[lBasisVectors]}],
        FundamentalRegionGF[First[WallpaperGroupData[[n,5]] @@
           lBasisVectors]], getWallpaperGroupUnitMotif[n,
         First[lBasisVectors], Last[lBasisVectors],
         GlideReflectionGF[First[#1], Last[#1]] & ,
         MirrorLineGF[First[#1], Last[#1]] & , RotationSymbolGF]},
       {{}, {}, {}}]; wallpaperGP = fundamentalMotifToUnitMotif[n,
       N[lMotifGraphics], First[lBasisVectors], Last[lBasisVectors]];
     (Show[Graphics[#1, Sequence @@ FilterRules[
           Flatten[{opts, Options[WallpaperPlot]}], Options[Graphics]],
         AspectRatio -> Automatic]] & )[
      Map[Translate2DGraphics[#1][{unitCellGP, fundamentalRegionGP,
          wallpaperGP, symmetryElementsGP}] & ,
       With[{a = First[lBasisVectors], b = Last[lBasisVectors],
         c = If[lCenterGraphics, (1/2)*Plus @@ (lBasisVectors*
              lPlotPoints), 0]}, N[Table[a*i + b*j - c,
          {j, 0, Last[lPlotPoints] - 1}, {i, 0, First[lPlotPoints] -
            1}]]], {2}]]];

MapThread[(WallpaperPlot[#2|#3,opts___]:=WallpaperPlot[#1,opts])&,(Part[#,Range@3]&)@(Transpose[WallpaperGroupData])];

Clear[RandomWallpaperPlot];

RandomWallpaperPlot::"usage" =
"RandomWallpaperPlot[n,(opts)] plots a random wallpaper with nth symmetry group.
RandomWallpaperPlot[n,m,s,r,(opts)] base it on m-gons (m = 3, 4, 6) with side length s (0.05 <= s <= .5).
r controls the randomness of the wallpaper. (0 < r <=1)
Special options are: ColorFunction->(RandomColor) can be used to specify color.
PlotPoints->{4,4} can be specified to control the number of cells in the plot.
Example:
RandomWallpaperPlot[17,3,.1,1,PlotPoints->{3,3}]
";

Options[RandomWallpaperPlot] = Union[
{BasisVectors -> Automatic,
ColorFunction -> RandomColor,
PlotPoints -> {4, 4}},
Options[Graphics] /. {(AspectRatio -> _) :> AspectRatio -> Automatic}];

RandomWallpaperPlot[n_Integer, opts___] :=
   Module[{random1 = 1 - RandomReal[]/2}, RandomWallpaperPlot[n, 6,
      0.1, random1, opts]] /; 1 <= n <= 17 &&
     And @@ (#1 === Rule || #1 === RuleDelayed & ) /@
       Union[Head /@ {opts}];

RandomWallpaperPlot[n_Integer, m:3 | 4 | 6, sideLength_, r_,
    opts___] := Module[{basisVectors, colorFunction, plotPoints,
      allUnitCellsRange, fundamentalRegionRange, motifGP},
     basisVectors = N[BasisVectors /. {opts} /.
         Options[RandomWallpaperPlot]]; colorFunction =
       N[ColorFunction /. {opts} /. Options[RandomWallpaperPlot]];
      plotPoints = N[PlotPoints /. {opts} /.
         Options[RandomWallpaperPlot]]; plotPoints =
       {First[Flatten[{plotPoints}]], Last[Flatten[{plotPoints}]]};
      If[basisVectors === Automatic, basisVectors =
        N[WallpaperGroupData[[n,4]]]]; allUnitCellsRange =
       ({Min[#1], Max[#1]} & ) /@ Transpose[(Flatten[#1, 1] & )[
          ({{0, 0}, First[#1], First[#1] + Last[#1], Last[#1]} & ) /@
           Transpose[WallpaperGroupData][[4]]]];
      fundamentalRegionRange = ({Min[#1], Max[#1]} & ) /@
        Transpose @@ WallpaperGroupData[[n,5]] @@ basisVectors;
      motifGP = StainedGlassMotif[m, sideLength, r,
        fundamentalRegionRange]; motifGP =
       Fold[#1 /. p_Polygon :> First[SlicePolygon[p, #2]] & , motifGP,
        Partition[WallpaperGroupData[[n,5]] @@ basisVectors /.
          Polygon[{a_, rest__}] :> {a, rest, a}, 2, 1]];
      motifGP = motifGP /. p_Polygon :> {colorFunction[], p};
{
      Show[Graphics[{{GrayLevel[0.9], Polygon[
            ({{0, 0}, First[#1], First[#1] + Last[#1], Last[#1]} & )[
             basisVectors]]}, motifGP, First[WallpaperPlot[n,
            MotifGraphics -> {}, ShowSymmetryAndUnitCellGraphics ->
             True, BasisVectors -> basisVectors, PlotPoints -> {1, 1},
            DisplayFunction -> Identity]]}], AspectRatio -> Automatic,
        PlotRange -> {{-1, 1}, {-1, 1}}*0.1 + allUnitCellsRange,
        Sequence @@ FilterRules[Flatten[{opts, Options[
             RandomWallpaperPlot]}], Options[Graphics]], Frame -> True],
       WallpaperPlot[n, MotifGraphics -> motifGP, BasisVectors ->
         basisVectors, PlotPoints -> plotPoints,
        Sequence @@ FilterRules[Flatten[{opts}],
          Options[Graphics]]]
}
] /; 1 <= n <= 17 &&
     0.02 <= N[sideLength] <= 1 && 0 <= N[r] <= 1 &&
     And @@ (#1 === Rule || #1 === RuleDelayed & ) /@
       Union[Head /@ {opts}];

(*sideLength=Which[m===3,Sqrt[4/Sqrt[3]*area1],m===4,Sqrt@area1,m===6,Sqrt[2/(Sqrt[3]*3)*area1]];*)

End[];

(*lattice and grids*)
Protect[LatticeCoordinates,
ColoredLatticePoints,
ColoredLatticeNetwork,
DirectedLatticeNetwork];

(*motif*)
Protect[PolygonMotif,
PolygonMotif2,
StarMotif,
NestedPolygonMotif,
RotationSymbolMotif,
RotationSymbolMotif2,

ArrowMotif,
VectorMotif,
DoubleLineMotif,
RosetteMotif,
StainedGlassMotif
];

Protect[ LineTransform ];

(*graphics transformations*)
Protect[Transform2DGraphics,
Translate2DGraphics,
Rotate2DGraphics,
Reflect2DGraphics,
GlideReflect2DGraphics];

(*graphics cutting*)
Protect[PolygonCounterOrientedQ,
LineIntersectionPoint,
PointOnLeftSideQ,
PointOnLeftSideQCompiled,
CutPolygon,
SlicePolygon,
SlitLine,
CutLine,
SliceLine,
Wireframe2DGraphics,
ConvertCircleToLine,
Cut2DGraphics,
Slice2DGraphics,
CookieStamp2DGraphics];

(*Wallpaper plotters*)
Protect[WallpaperGroupData,
Translation,
GlideReflection,
Reflection,
Rotation,

MotifGraphics,
BasisVectors,
ShowSymmetryAndUnitCellGraphics,
CenterGraphics,

UnitCellGraphicsFunction,
FundamentalRegionGraphicsFunction,
GlideReflectionGraphicsFunction,
MirrorLineGraphicsFunction,
RotationSymbolGraphicsFunction,

WallpaperPlot,
RandomWallpaperPlot];

EndPackage[];
